(ns ui.element.numbers.views
  (:require [#?(:clj clojure.core :cljs reagent.core) :refer [atom]]
            [clojure.string :as str]
            [re-frame.core :as re-frame]
            [ui.element.button :refer [button]]
            [ui.element.checkbox :refer [checkbox]]
            [ui.element.chooser :refer [chooser]]
            [ui.element.clamp :refer [clamp]]
            [ui.element.containers :refer [container]]
            [ui.element.menu :as menu]
            [ui.element.textfield :refer [textfield]]
            [ui.util :as util]
            [ui.wire.polyglot :as polyglot :refer [translate]]
            [ui.element.numbers.events]
            [ui.element.numbers.subs]
            [reagent.core :as reagent]))


(def element-value #(.-value (.-target %)))


;; TODO Range-filter for numbers
;; TODO Date-filtering
;; TODO Make a permanent footer (Removes the little border issue at the bottom)
;; TODO Convert to title-row add/remove row hide row
;; TODO Replace spacer with a drop-down


(defn- colgroup []
  [:colgroup]
  #_(let [pad           (- (count columns) (or (count column-widths) 0))
        column-widths (-> (mapv #(if (int? %) (+ % 20) :auto) column-widths)
                         (into (vec (take pad (repeat :auto)))))]
    (into [:colgroup] (->> columns
                         (map-indexed
                          (fn [n column]
                            (when-not (contains? hide-columns (:col-ref column))
                              (let [width (nth column-widths n)
                                    ref   (if-not (nil? (:col-ref column)) (:col-ref column) n)]
                                [:col {:key (str id "-" ref) :width width}]))))))))

;; [colgroup "headers"
;;  (if (= row-heading :hidden) @columns (into [nil nil] @columns))
;;  (if (= row-heading :hidden)
;;    column-widths
;;    (into [20 0] column-widths)) hide-columns]

(defn- table
  [& content]
  (into [:table {:cell-padding 0 :cell-spacing 0}
         [colgroup]] content))


(defn- string-filter
  "Outputs a list of unique values of a column"
  [sheet-ref col-ref]
  (let [;; filter-eq (fn [id value] #(re-frame/dispatch [:filter-eq sheet-ref col-ref value id]))
        ;; filter-smart-case #(re-frame/dispatch [:filter-smart-case sheet-ref col-ref
        ;; (element-value %)])
        ;; query             @(re-frame/subscribe [:query sheet-ref col-ref])
        ;; unique @(re-frame/subscribe [:unique-values sheet-ref col-ref])
        ]
    [:div]
    #_[:div
     [textfield {:label     "Search"
                 :value     query
                 :on-change filter-smart-case}]
     [:br]
     (doall (for [n (range (count unique))]
              (let [value (nth unique n)
                    id (util/slug "filter" col-ref n)
                    checked @(re-frame/subscribe [:checkbox sheet-ref col-ref id])]
                [checkbox
                 {:id id
                  :key (util/slug "key" id)
                  :checked checked
                  :value value
                  :on-change (filter-eq id value)} value])))]))


(defn- date-filter
  "Output a date-picker"
  [sheet-ref col-ref]
  [:span])


(defn- number-filter
  "Output a range slider with multiple knobs"
  [sheet-ref col-ref]
  [:span]
  #_(let [values @(re-frame/subscribe [:unique-values sheet-ref col-ref])
        on-change #(re-frame/dispatch [:filter-range sheet-ref col-ref %])]
    [clamp
     {:id (util/slug "filter" col-ref "range")
      :labels? true
      :on-change on-change
      :range :both} values]))


(defn- column-menu
  "A dropd-down menu for each column of a worksheet for filtering and
  sorting the results"
  [sheet-ref col-ref]
  (let [column @(re-frame/subscribe [:column sheet-ref col-ref])
        show-column-menu? @(re-frame/subscribe [:show-column-menu? sheet-ref col-ref])
        sort-ascending #(re-frame/dispatch [:sort-column sheet-ref col-ref true])
        sort-descending #(re-frame/dispatch [:sort-column sheet-ref col-ref false])]
    [menu/dropdown {:open? show-column-menu?}
     [container {:layout :vertically :gap? false :fill? true}
      [button
       {:key (str col-ref "-sort-asc")
        :fill true
        :class "secondary"
        :on-click sort-ascending} (translate :ui/sort-ascending)]
      [button
       {:key (str col-ref "-sort-dsc")
        :fill true
        :class "secondary"
        :on-click sort-descending} (translate :ui/sort-descending)]
      [container
       {:layout :vertically
        :wrap? false
        :fill? true
        :gap? false
        :style {:max-height "25em" :overflow :auto}}
       (case (:type column)
         :number [number-filter sheet-ref col-ref]
         :inst [date-filter sheet-ref col-ref]
         [string-filter sheet-ref col-ref])]]]))


(defn- table-heading
  "Headings include column-headings caption and all of the title-rows"
  [sheet-ref
   {:keys [caption? row-heading column-heading hide-columns]
    :or   {column-heading :hidden row-heading :hidden hide-columns #{}}}]
  (let [col-refs           @(re-frame/subscribe [:col-refs sheet-ref])
        column-count       @(re-frame/subscribe [:num-columns sheet-ref])
        title-rows         @(re-frame/subscribe [:title-rows sheet-ref])
        sort-ascending?    @(re-frame/subscribe [:sort-ascending? sheet-ref] {})
        sorted-column      @(re-frame/subscribe [:sorted-column sheet-ref])
        toggle-column-menu (fn [col-ref] #(re-frame/dispatch [:show-column-menu sheet-ref col-ref]))]
    [:thead
     (when-not (= column-heading :hidden)
       [:tr.Column-headings {:key "Column-headings"}
        (if (= row-heading :select)
          [:th.Select {:key "Column-select"} [:input {:type :checkbox}]]
          (when-not (= row-heading :hidden)
            [:th {:key "Column-filler" :style {:border 0}}]))
        (when-not (= row-heading :hidden)
          [:th {:style {:border-top 0 :border-bottom 0}}])
        (->> col-refs
           (map #(when-not (contains? hide-columns (util/col-ref %))
                   [:th.Column-heading
                    {:key   (str "Column-" (name column-heading) %)
                     :class (name column-heading)}
                    (case column-heading
                      :numeric (util/col-num %)
                      :alpha   %)
                    [:button.Dropdown-origin {:on-click (toggle-column-menu %)}
                     "›"] [column-menu sheet-ref %]])))]) ;; Caption
     (when (or caption? (not= column-heading :hidden))
       [:tr {:key "Column-Spacer"}
        (when (and (not= column-heading :hidden) (not= row-heading :hidden))
          [:th {:style {:border-left 0 :border-right 0}}])
        (when (and (not= column-heading :hidden) (not= row-heading :hidden))
          [:th {:style {:border-left 0 :border-right 0 :border-bottom 0}}])
        [:th
         {:col-span (- column-count (count hide-columns))
          :style    {:border-left 0 :border-right 0}}
         (when caption? [:h2.Caption (str sheet-ref)])]])
     (when-not (empty? title-rows)
       (->> title-rows
          (map
           (fn [row]
             (let [row-num (:row-n (first row))]
               [:tr.Titlerow {:key (str "Titlerow-" row-num)}
                (when-not (= row-heading :hidden)
                  [:th.numeric
                   {:style (if (= column-heading :hidden)
                             {:border-top "1px solid rgb(230230230)"}
                             {})} row-num])
                (when-not (= row-heading :hidden)
                  [:th {:style {:border-top 0 :border-bottom 0}}])
                (map-indexed
                 (fn [n title]
                   (let [n (inc n)]
                     (when-not (contains? hide-columns
                                          (util/col-ref (:cell-ref title)))
                       [:th.Titlecolumn {:key (str "Title-" n)}
                        [:span (:value title)]
                        (when (= sorted-column (util/col-ref (:cell-ref title)))
                          [:span.Arrow (if sort-ascending? "↑" "↓")])
                        (when (and (= column-heading :hidden) (= row-num 1))
                          [:span
                           [:button.Dropdown-origin
                            {:on-click (toggle-column-menu
                                        (util/col-ref (:cell-ref title)))} "›"]
                           [column-menu sheet-ref
                            (util/col-ref (:cell-ref title))]])])))
                 row)])))))]))


(defn- table-body-row [sheet-ref row]
  (let [[st-col]                                     row
        row-num                                      (:row-n st-col)
        state                                        @(re-frame/subscribe [:state sheet-ref])
        {:keys [row-heading hide-columns editable? on-double-click lock-columns]} state
        on-double-click-local                        (fn [m] #(on-double-click (merge m {:event %})))]
    [:tr {:key (util/slug "row" row-num)}
     (when-not (= row-heading :hidden)
       (case row-heading
         :numeric [:td.numeric {:class (if (>= row-num 100) "smaller" "")}
                   row-num]
         :select  [:td.select [:input {:type :checkbox}]]
         [:td]))
     (when-not (= row-heading :hidden)
       [:td.spacer {:style {:border-top 0 :border-bottom 0}}])
     (->> row
        (map (fn [{:keys [cell-ref value align fill] :as c}]
               (when-not (contains? hide-columns (util/col-ref cell-ref))
                 (let [editable? (if (and (meta value)
                                          (not (nil? (:editable? (meta value)))))
                                   (:editable? (meta value))
                                   editable?)
                       k         (merge {:key   cell-ref
                                         :style (merge {}
                                                       (when ((complement nil?) align)
                                                         {:text-align align})
                                                       (when ((complement nil?) fill)
                                                         {:background fill}))
                                         :on-double-click
                                         (on-double-click-local
                                          {:editable (and editable?
                                                          (not (contains? lock-columns
                                                                          (util/col-ref
                                                                           cell-ref))))
                                           :cell-ref cell-ref})
                                         :class (util/names->str
                                                 [(if editable? :editable :not-editable)
                                                  #_(when (and (> (count lock-columns) x)
                                                               (nth lock-columns x))
                                                      :Lock-Columns)])}
                                        (when editable? {:title cell-ref}))]
                   (cond (number? value) [:td.cell.number k
                                          [:span (number-formatter value)]]
                         (inst? value)   [:td.cell.date k
                                          [:span (inst-formatter value)]]
                         (map? value)    [:td.cell.chooser k
                                          (let [{:keys [items selected]} value]
                                            [chooser {:id         (util/slug "chooser" cell-ref)
                                                      :label      (first selected)
                                                      :predicate? util/smart-case-includes?
                                                      :searchable true
                                                      :items      items
                                                      :on-select  #(util/log %)}])]
                         (vector? value) [:td.cell.custom k value]
                         (fn? value)
                         [:td.cell.custom k
                          (value {:row      row
                                  :editable (and editable? (not (contains? lock-columns (util/col-ref cell-ref))))
                                  :cell-ref cell-ref})]
                         :else           [:td.cell.string k
                                          (when-not (nil? value)
                                            (if (str/starts-with? value "http")
                                              [:a {:href value} value]
                                              [:span value]))]))))))]))


(defn- table-body
  [sheet-ref
   {:keys [editable? row-heading number-formatter inst-formatter on-double-click
           hide-columns lock-columns]
    :or   {row-heading      :hidden
           number-formatter polyglot/format-number-en
           inst-formatter   polyglot/format-inst
           hide-columns     #{}
           lock-columns     #{}}} row-n]
  (let [rows                  @(re-frame/subscribe [:rows sheet-ref])]
    [:tbody
     (for [row rows]
       [table-body-row sheet-ref row])]))


(defn sheet [{:keys [hidden] :as params} data]
  (let [sheet-ref (:name params)]
    (re-frame/dispatch [:sheet sheet-ref params data])
    (fn [params data]
      ;; let [classes (util/names->str (into [(when editable? :editable) (when caption? :caption)] (:class params)))]
      (when-not hidden
        [:div.Worksheet.fill {:key sheet-ref}
         [:div.Table
          [:div.Table-Header
             [table [table-heading sheet-ref params]]]
          [:div.Table-Body
             [table [table-body sheet-ref]]]]]))))

